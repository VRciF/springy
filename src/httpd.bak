#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>
#include <net/if.h>

#include <time.h>
#include <errno.h>
#include <limits.h>

#include <microhttpd.h>

#include "httpd.h"
#include "parse_options.h"
#include "tools.h"
#include "md5.h"

struct MHD_Daemon *httpd;
char httpd_rnd[8];

#define MAX_NONCE_LENGTH 129
#define HASH_MD5_HEX_LEN (2 * MD5_DIGEST_SIZE)

/**
 * Beginning string for any valid Digest authentication header.
 */
#define _BASE		"Digest "

/**
 * Maximum length of a username for digest authentication.
 */
#define MAX_USERNAME_LENGTH 128

/**
 * Maximum length of a realm for digest authentication.
 */
#define MAX_REALM_LENGTH 256

/**
 * Maximum length of the response in digest authentication.
 */
#define MAX_AUTH_RESPONSE_LENGTH 128
/**
 * convert bin to hex
 *
 * @param bin binary data
 * @param len number of bytes in bin
 * @param hex pointer to len*2+1 bytes
 */
static void
cvthex (const unsigned char *bin,
	size_t len,
	char *hex)
{
  size_t i;
  unsigned int j;

  for (i = 0; i < len; ++i)
    {
      j = (bin[i] >> 4) & 0x0f;
      hex[i * 2] = j <= 9 ? (j + '0') : (j + 'a' - 10);
      j = bin[i] & 0x0f;
      hex[i * 2 + 1] = j <= 9 ? (j + '0') : (j + 'a' - 10);
    }
  hex[len * 2] = '\0';
}

/**
 * Lookup subvalue off of the HTTP Authorization header.
 *
 * A description of the input format for 'data' is at
 * http://en.wikipedia.org/wiki/Digest_access_authentication
 *
 *
 * @param dest where to store the result (possibly truncated if
 *             the buffer is not big enough).
 * @param size size of dest
 * @param data pointer to the Authorization header
 * @param key key to look up in data
 * @return size of the located value, 0 if otherwise
 */
static size_t
lookup_sub_value (char *dest,
		  size_t size,
		  const char *data,
		  const char *key)
{
  size_t keylen;
  size_t len;
  const char *ptr;
  const char *eq;
  const char *q1;
  const char *q2;
  const char *qn;

  if (0 == size)
    return 0;
  keylen = strlen (key);
  ptr = data;
  while ('\0' != *ptr)
    {
      if (NULL == (eq = strchr (ptr, '=')))
	return 0;
      q1 = eq + 1;
      while (' ' == *q1)
	q1++;
      if ('\"' != *q1)
	{
	  q2 = strchr (q1, ',');
	  qn = q2;
	}
      else
	{
	  q1++;
	  q2 = strchr (q1, '\"');
	  if (NULL == q2)
	    return 0; /* end quote not found */
	  qn = q2 + 1;
	}
    if ((0==strncasecmp(ptr,
			      key,
			      keylen)) &&
	   (eq == &ptr[keylen]) )
	{
	  if (NULL == q2)
	    {
	      len = strlen (q1) + 1;
	      if (size > len)
		size = len;
	      size--;
	      strncpy (dest,
		       q1,
		       size);
	      dest[size] = '\0';
	      return size;
	    }
	  else
	    {
	      if (size > (size_t) ((q2 - q1) + 1))
		size = (q2 - q1) + 1;
	      size--;
	      memcpy (dest,
		      q1,
		      size);
	      dest[size] = '\0';
	      return size;
	    }
	}
      if (NULL == qn)
	return 0;
      ptr = strchr (qn, ',');
      if (NULL == ptr)
	return 0;
      ptr++;
      while (' ' == *ptr)
	ptr++;
    }
  return 0;
}

/**
 * Calculate the server nonce so that it mitigates replay attacks
 * The current format of the nonce is ...
 * H(timestamp ":" method ":" random ":" uri ":" realm) + Hex(timestamp)
 *
 * @param nonce_time The amount of time in seconds for a nonce to be invalid
 * @param method HTTP method
 * @param rnd A pointer to a character array for the random seed
 * @param rnd_size The size of the random seed array @a rnd
 * @param uri HTTP URI (in MHD, without the arguments ("?k=v")
 * @param realm A string of characters that describes the realm of auth.
 * @param nonce A pointer to a character array for the nonce to put in
 */
static void
calculate_nonce (uint32_t nonce_time,
		 const char *method,
		 const char *rnd,
		 size_t rnd_size,
		 const char *uri,
		 const char *realm,
		 char *nonce)
{
  struct MD5Context md5;
  unsigned char timestamp[4];
  unsigned char tmpnonce[MD5_DIGEST_SIZE];
  char timestamphex[sizeof(timestamp) * 2 + 1];

  MD5Init (&md5);
  timestamp[0] = (nonce_time & 0xff000000) >> 0x18;
  timestamp[1] = (nonce_time & 0x00ff0000) >> 0x10;
  timestamp[2] = (nonce_time & 0x0000ff00) >> 0x08;
  timestamp[3] = (nonce_time & 0x000000ff);
  MD5Update (&md5, timestamp, 4);
  MD5Update (&md5, ":", 1);
  MD5Update (&md5, method, strlen (method));
  MD5Update (&md5, ":", 1);
  if (rnd_size > 0)
    MD5Update (&md5, rnd, rnd_size);
  MD5Update (&md5, ":", 1);
  MD5Update (&md5, uri, strlen (uri));
  MD5Update (&md5, ":", 1);
  MD5Update (&md5, realm, strlen (realm));
  MD5Final (tmpnonce, &md5);
  cvthex (tmpnonce, sizeof (tmpnonce), nonce);
  cvthex (timestamp, 4, timestamphex);
  strncat (nonce, timestamphex, 8);
}
/**
 * Test if the given key-value pair is in the headers for the
 * given connection.
 *
 * @param connection the connection
 * @param key the key
 * @param value the value, can be NULL
 * @return #MHD_YES if the key-value pair is in the headers,
 *         #MHD_NO if not
 */
static int
test_header (struct MHD_Connection *connection,
	     const char *key,
	     const char *value)
{
    
  const char *headerval = MHD_lookup_connection_value (connection,
                                           MHD_HEADER_KIND,
                                           key);
  if(headerval==NULL || strcmp(headerval, value)!=0){
      return MHD_NO;
  }
  return MHD_YES;
}

int ishex(int x)
{
	return	(x >= '0' && x <= '9')	||
		(x >= 'a' && x <= 'f')	||
		(x >= 'A' && x <= 'F');
}
int decodeUrl(char *dec)
{
	char *o;
	unsigned int c;
    char *s = strdup(dec);
    const char *end = dec+strlen(dec);
    if(s==NULL){ return 0; }
 
	for (o = dec; s <= end; o++) {
		c = *s++;
		if (c == '+') c = ' ';
		else if (c == '%' && (	!ishex(*s++)	||
					!ishex(*s++)	||
					!sscanf(s - 2, "%2x", &c))){
            free(s);
			return -1;
        }
 
		if (dec) *o = c;
	}
    *o = '\0';
    free(s);
 
	return o - dec;
}

/**
 * Check that the arguments given by the client as part
 * of the authentication header match the arguments we
 * got as part of the HTTP request URI.
 *
 * @param connection connections with headers to compare against
 * @param args argument URI string (after "?" in URI)
 * @return MHD_YES if the arguments match,
 *         MHD_NO if not
 */
static int
check_argument_match (struct MHD_Connection *connection,
		      const char *args)
{
  char *argb;
  char *argp;
  char *equals;
  char *amper;
  unsigned int num_headers;

  argb = strdup(args);
  if (NULL == argb)
  {
#if HAVE_MESSAGES
    MHD_DLOG(connection->daemon,
             "Failed to allocate memory for copy of URI arguments\n");
#endif /* HAVE_MESSAGES */
    return MHD_NO;
  }
  num_headers = 0;
  argp = argb;
  while ( (NULL != argp) &&
	  ('\0' != argp[0]) )
    {
      equals = strchr (argp, '=');
      if (NULL == equals)
	{
	  /* add with 'value' NULL */
      decodeUrl(argp);

	  if (MHD_YES != test_header (connection, argp, NULL))
	    return MHD_NO;
	  num_headers++;
	  break;
	}
      equals[0] = '\0';
      equals++;
      amper = strchr (equals, '&');
      if (NULL != amper)
	{
	  amper[0] = '\0';
	  amper++;
	}
      decodeUrl(argp);
      decodeUrl(equals);

      if (! test_header (connection, argp, equals))
	return MHD_NO;
      num_headers++;
      argp = amper;
    }

  return MHD_YES;
}


/**
 * Calculate request-digest/response-digest as per RFC2617 spec
 *
 * @param ha1 H(A1)
 * @param nonce nonce from server
 * @param noncecount 8 hex digits
 * @param cnonce client nonce
 * @param qop qop-value: "", "auth" or "auth-int"
 * @param method method from request
 * @param uri requested URL
 * @param hentity H(entity body) if qop="auth-int"
 * @param response request-digest or response-digest
 */
static void
digest_calc_response (const char *ha1,
		      const char *nonce,
		      const char *noncecount,
		      const char *cnonce,
		      const char *qop,
		      const char *method,
		      const char *uri,
		      const char *hentity,
		      char *response)
{
  struct MD5Context md5;
  unsigned char ha2[MD5_DIGEST_SIZE];
  unsigned char resphash[MD5_DIGEST_SIZE];
  char ha2hex[HASH_MD5_HEX_LEN + 1];

  MD5Init (&md5);
  MD5Update (&md5, method, strlen(method));
  MD5Update (&md5, ":", 1);
  MD5Update (&md5, uri, strlen(uri));
#if 0
  if (0 == strcasecmp(qop, "auth-int"))
    {
      /* This is dead code since the rest of this module does
	 not support auth-int. */
      MD5Update (&md5, ":", 1);
      if (NULL != hentity)
	MD5Update (&md5, hentity, strlen(hentity));
    }
#endif
  MD5Final (ha2, &md5);
  cvthex (ha2, MD5_DIGEST_SIZE, ha2hex);
  MD5Init (&md5);
  /* calculate response */
  MD5Update (&md5, ha1, HASH_MD5_HEX_LEN);
  MD5Update (&md5, ":", 1);
  MD5Update (&md5, nonce, strlen(nonce));
  MD5Update (&md5, ":", 1);
  if ('\0' != *qop)
    {
      MD5Update (&md5, noncecount, strlen(noncecount));
      MD5Update (&md5, ":", 1);
      MD5Update (&md5, cnonce, strlen(cnonce));
      MD5Update (&md5, ":", 1);
      MD5Update (&md5, qop, strlen(qop));
      MD5Update (&md5, ":", 1);
    }
  MD5Update (&md5, ha2hex, HASH_MD5_HEX_LEN);
  MD5Final (resphash, &md5);
  cvthex (resphash, sizeof (resphash), response);
}
/**
 * Authenticates the authorization header sent by the client
 *
 * @param connection The MHD connection structure
 * @param realm The realm presented to the client
 * @param username The username needs to be authenticated
 * @param password The password used in the authentication
 * @param nonce_timeout The amount of time for a nonce to be
 * 			invalid in seconds
 * @return #MHD_YES if authenticated, #MHD_NO if not,
 * 			#MHD_INVALID_NONCE if nonce is invalid
 * @ingroup authentication
 */
int
mhddfs_httpd_digest_auth_check (struct MHD_Connection *connection,
		       const char *realm,
		       const char *username,
		       const char *ha1,
		       unsigned int nonce_timeout,
               const char * url,
               const char * method)
{
  size_t len;
  const char *header;
  char *end;
  char nonce[MAX_NONCE_LENGTH];
  char cnonce[MAX_NONCE_LENGTH];
  char qop[15]; /* auth,auth-int */
  char nc[20];
  char response[MAX_AUTH_RESPONSE_LENGTH];
  const char *hentity = NULL; /* "auth-int" is not supported */
  char respexp[HASH_MD5_HEX_LEN + 1];
  char noncehashexp[HASH_MD5_HEX_LEN + 9];
  uint32_t nonce_time;
  uint32_t t;
  size_t left; /* number of characters left in 'header' for 'uri' */
  unsigned long int nci;

  header = MHD_lookup_connection_value (connection,
					MHD_HEADER_KIND,
					MHD_HTTP_HEADER_AUTHORIZATION);
  if (NULL == header)
    return MHD_NO;
  if (0 != strncmp(header, _BASE, strlen(_BASE)))
    return MHD_NO;
  header += strlen (_BASE);
  left = strlen (header);

  {
    char un[MAX_USERNAME_LENGTH];

    len = lookup_sub_value (un,
			    sizeof (un),
			    header, "username");
    if ( (0 == len) ||
	 (0 != strcmp(username, un)) )
      return MHD_NO;
    left -= strlen ("username") + len;
  }

  {
    char r[MAX_REALM_LENGTH];

    len = lookup_sub_value(r,
			   sizeof (r),
			   header, "realm");
    if ( (0 == len) ||
	 (0 != strcmp(realm, r)) )
      return MHD_NO;
    left -= strlen ("realm") + len;
  }

  if (0 == (len = lookup_sub_value (nonce,
				    sizeof (nonce),
				    header, "nonce")))
    return MHD_NO;
  left -= strlen ("nonce") + len;
  if (left > 32 * 1024)
  {
    /* we do not permit URIs longer than 32k, as we want to
       make sure to not blow our stack (or per-connection
       heap memory limit).  Besides, 32k is already insanely
       large, but of course in theory the
       #MHD_OPTION_CONNECTION_MEMORY_LIMIT might be very large
       and would thus permit sending a >32k authorization
       header value. */
    return MHD_NO;
  }
  {
    char *uri;
    
    uri = malloc(left + 1);
    if (NULL == uri)
    {
#if HAVE_MESSAGES
      MHD_DLOG(connection->daemon,
               "Failed to allocate memory for auth header processing\n");
#endif /* HAVE_MESSAGES */
      return MHD_NO;
    }
    if (0 == lookup_sub_value (uri,
                               left + 1,
                               header, "uri"))
    {
      free(uri);
      return MHD_NO;
    }

    /* 8 = 4 hexadecimal numbers for the timestamp */
    nonce_time = strtoul (nonce + len - 8, (char **)NULL, 16);
    t = (uint32_t) time(NULL);
    /*
     * First level vetting for the nonce validity: if the timestamp
     * attached to the nonce exceeds `nonce_timeout', then the nonce is
     * invalid.
     */
    if ( (t > nonce_time + nonce_timeout) ||
	 (nonce_time + nonce_timeout < nonce_time) )
    { 
      free(uri);
      return MHD_INVALID_NONCE;
    }
    if (0 != strncmp (uri,
		      url,
		      strlen (url)))
    {
#if HAVE_MESSAGES
      MHD_DLOG (connection->daemon,
		"Authentication failed, URI does not match.\n");
#endif
      free(uri);
      return MHD_NO;
    }
    {
      const char *args = strchr (uri, '?');

      if (NULL == args)
	args = "";
      else
	args++;
      if (MHD_YES !=
	  check_argument_match (connection,
				args) )
      {
#if HAVE_MESSAGES
	MHD_DLOG (connection->daemon,
		  "Authentication failed, arguments do not match.\n");
#endif
       free(uri);
       return MHD_NO;
      }
    }
    calculate_nonce (nonce_time,
		     method,
		     httpd_rnd,
		     sizeof(httpd_rnd),
		     url,
		     realm,
		     noncehashexp);
    /*
     * Second level vetting for the nonce validity
     * if the timestamp attached to the nonce is valid
     * and possibly fabricated (in case of an attack)
     * the attacker must also know the random seed to be
     * able to generate a "sane" nonce, which if he does
     * not, the nonce fabrication process going to be
     * very hard to achieve.
     */

    if (0 != strcmp (nonce, noncehashexp))
    {
      free(uri);
      return MHD_INVALID_NONCE;
    }
    if ( (0 == lookup_sub_value (cnonce,
				 sizeof (cnonce),
				 header, "cnonce")) ||
	 (0 == lookup_sub_value (qop, sizeof (qop), header, "qop")) ||
	 ( (0 != strcmp (qop, "auth")) &&
	   (0 != strcmp (qop, "")) ) ||
	 (0 == lookup_sub_value (nc, sizeof (nc), header, "nc"))  ||
	 (0 == lookup_sub_value (response, sizeof (response), header, "response")) )
    {
#if HAVE_MESSAGES
      MHD_DLOG (connection->daemon,
		"Authentication failed, invalid format.\n");
#endif
      free(uri);
      return MHD_NO;
    }
    nci = strtoul (nc, &end, 16);
    if ( ('\0' != *end) ||
	 ( (LONG_MAX == nci) &&
	   (ERANGE == errno) ) )
    {
#if HAVE_MESSAGES
      MHD_DLOG (connection->daemon,
		"Authentication failed, invalid format.\n");
#endif
      free(uri);
      return MHD_NO; /* invalid nonce format */
    }
    /*
     * Checking if that combination of nonce and nc is sound
     * and not a replay attack attempt. Also adds the nonce
     * to the nonce-nc map if it does not exist there.
     */

    /*if (MHD_YES != check_nonce_nc (connection, nonce, nci))
    {
      free(uri);
      return MHD_NO;
    }
    */

    digest_calc_response (ha1,
			  nonce,
			  nc,
			  cnonce,
			  qop,
			  method,
			  uri,
			  hentity,
			  respexp);
    free(uri);
    return (0 == strcmp(response, respexp))
      ? MHD_YES
      : MHD_NO;
  }
}

int mhdd_httpd_serve(void * cls,
		    struct MHD_Connection * connection,
		    const char * url,
		    const char * method,
                    const char * version,
		    const char * upload_data,
		    size_t * upload_data_size,
                    void ** ptr){
  struct MHD_Response * response;
  int ret;
  char *cokresponse = "{success: true, message: '', data: ''}";
  char *cnokresponse = "{success: false, message: '', data: ''}";
  const char *header;
  char *username;
  char *realm;
  char *ha1;
  char *plainpassword = NULL;
  const char *opaque = "226c8080522afa1fec99f262ec8fb7f3261cface";
  char *htdigest = NULL;
  char *tok=NULL, *lasts = NULL,*lasts2=NULL;

  const char *param_callback = NULL;
  const char *param_directory = NULL;

  printf("%s\n", url);
  param_callback = MHD_lookup_connection_value(
         connection,
         MHD_GET_ARGUMENT_KIND,
         "callback");

  if (0 == strcmp(method, "OPTIONS")){
     header = MHD_lookup_connection_value (connection,
                                           MHD_HEADER_KIND,
                                           "Access-Control-Request-Headers");
    response = MHD_create_response_from_buffer(strlen (cnokresponse),
                                               cnokresponse,
                                               MHD_RESPMEM_PERSISTENT);
    if (NULL == response)
        return MHD_NO;
    MHD_add_response_header(response,
				            "Access-Control-Allow-Origin",
				            "*");
    MHD_add_response_header(response,
				            "Access-Control-Allow-Methods",
				            "POST, GET, OPTIONS, HEAD, PUT, DELETE");
    MHD_add_response_header(response,
				            "Access-Control-Max-Age",
				            "1728000");
    if(header!=NULL){
        MHD_add_response_header(response,
                                "Access-Control-Allow-Headers",
                                header);
    }
    ret = MHD_queue_response(connection, MHD_HTTP_OK, response);
    MHD_destroy_response(response);
    return ret;
  }

  if(mhdd.server_auth_password!=NULL){
      username = MHD_basic_auth_get_username_password (connection, &plainpassword);
      if(username==NULL){
          username = MHD_digest_auth_get_username(connection);
          if(username==NULL){
              header = MHD_lookup_connection_value (connection,
                                                    MHD_HEADER_KIND,
                                                    "Mhddfs-Authorization");
          }
          else{
              if(mhdd.server_auth_password!=NULL && mhdd.server_auth_realm!=NULL && mhdd.server_auth_password!=NULL){
                ret = MHD_digest_auth_check(connection, mhdd.server_auth_realm,
                                              mhdd.server_auth_username,
                                              mhdd.server_auth_password,
                                              300);
                free(username);
                  if ( (ret == MHD_INVALID_NONCE) ||
                       (ret == MHD_NO) )
                    {
                      response = MHD_create_response_from_buffer(strlen (cnokresponse),
                                         cnokresponse,
                                         MHD_RESPMEM_PERSISTENT);
                      if (NULL == response)
                    return MHD_NO;
                      ret = MHD_queue_auth_fail_response(connection, mhdd.server_auth_realm,
                                     opaque,
                                     response,
                                     (ret == MHD_INVALID_NONCE) ? MHD_YES : MHD_NO);
                      MHD_destroy_response(response);
                      return ret;
                    }
                    /* credentials valid */
              }
              else if(mhdd.server_auth_htdigest!=NULL){
                  free(username);
                  /* use htdigest file */
                  htdigest = file_get_contents(mhdd.server_auth_htdigest);
                  tok = strtok_r(htdigest, "\n", &lasts);
                  while (tok != NULL) {
                      if(strlen(tok)>0){
                          do{
                             username = strtok_r(tok, ":", &lasts2);
                             if(username==NULL) break;
                             realm = strtok_r(tok, ":", &lasts2);
                             if(realm==NULL) break;
                             ha1 = strtok_r(tok, ":", &lasts2);
                             if(ha1==NULL) break;

                             mhddfs_httpd_digest_auth_check(connection, realm, username, ha1, 300, url, method);
                          }while(0);
                          
                      }
                      tok = strtok_r(NULL, "\n", &lasts);
                  }
              }
              else{
                  free(username);
                  return MHD_NO;
              }
          }
          response = MHD_create_response_from_buffer(strlen (cnokresponse),
                             cnokresponse,
                             MHD_RESPMEM_PERSISTENT);
          ret = MHD_queue_auth_fail_response(connection, mhdd.server_auth_realm,
                         opaque,
                         response,
                         MHD_NO);
          MHD_destroy_response(response);
          return ret;
      }
      else{
          if(strcmp(username, mhdd.server_auth_username)!=0 || strcmp(plainpassword, mhdd.server_auth_password)!=0){
              /* invalid credentials */
              free(username);
              response = MHD_create_response_from_buffer(strlen (cnokresponse),
                                 cnokresponse,
                                 MHD_RESPMEM_PERSISTENT);
              if (NULL == response)
                  return MHD_NO;
              ret = MHD_queue_basic_auth_fail_response (connection,
				                                        mhdd.server_auth_realm, 
				                                        response);
              MHD_destroy_response(response);
              return ret;
          }
          else{
              /* credentials valid*/
              free(username);
          }
      }
  }
  

  if (0 != strcmp(method, "GET"))
    return MHD_NO; /* unexpected method */
  if (0 != *upload_data_size)
    return MHD_NO; /* upload data in a GET!? */

  param_directory = MHD_lookup_connection_value(
         connection,
         MHD_GET_ARGUMENT_KIND,
         "directory");
  if(strcmp(url, "/addDirectory")==0){
      if(param_directory==NULL){
          response = MHD_create_response_from_data(strlen(cnokresponse),
                               (void*) cnokresponse,
                               MHD_NO,
                               MHD_NO);
          ret = MHD_queue_response(connection,
                       MHD_HTTP_OK,
                       response);
          MHD_destroy_response(response);
          return ret;
      }

      add_mhdd_dirs(param_directory);
  }
  else if(strcmp(url, "/remDirectory")==0){
      if(param_directory==NULL){
          response = MHD_create_response_from_data(strlen(cnokresponse),
                               (void*) cnokresponse,
                               MHD_NO,
                               MHD_NO);
          ret = MHD_queue_response(connection,
                       MHD_HTTP_OK,
                       response);
          MHD_destroy_response(response);
          return ret;
      }

      rem_mhdd_dirs(param_directory);
  }
  else if(strcmp(url, "/settings")==0){
  }

  response = MHD_create_response_from_data(strlen(cokresponse),
					   (void*) cokresponse,
					   MHD_NO,
					   MHD_NO);
  ret = MHD_queue_response(connection,
			   MHD_HTTP_OK,
			   response);
  MHD_destroy_response(response);
  return ret;
}

struct MHD_Daemon * mhdd_httpd_startServer(){
    int fd, res;
    struct ifreq ifr;
    struct sockaddr_in address;
    int i=0;

    address.sin_family = AF_INET;
    address.sin_port = htons(mhdd.server_port);
    if(mhdd.server_iface==NULL){
        inet_pton(AF_INET, "0.0.0.0", &address.sin_addr);
    }
    else if(inet_pton(AF_INET, mhdd.server_iface, &address.sin_addr)==0){
        /* try assuming iface is the network interface name */
         fd = socket(AF_INET, SOCK_DGRAM, 0);
         /* I want to get an IPv4 IP address */
         ifr.ifr_addr.sa_family = AF_INET;
         /* I want IP address attached to "eth0" */
         strncpy(ifr.ifr_name, mhdd.server_iface, IFNAMSIZ-1);
         res = ioctl(fd, SIOCGIFADDR, &ifr);
         close(fd);
         if(res==-1){
             return NULL;
         }

         address.sin_addr = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr;
    }

    srand(time(NULL));
    for(i=0;i<sizeof(httpd_rnd);i++){
        httpd_rnd[i] = rand();
    }

    if(mhdd.server_cert_pem!=NULL && mhdd.server_key_pem!=NULL){
        httpd = MHD_start_daemon(MHD_USE_THREAD_PER_CONNECTION | MHD_USE_SSL,
                   mhdd.server_port,
                   NULL,
                   NULL,
                   &mhdd_httpd_serve,
                   NULL,
                   MHD_OPTION_SOCK_ADDR, &address,
                   MHD_OPTION_HTTPS_MEM_KEY, mhdd.server_key_pem,
                   MHD_OPTION_HTTPS_MEM_CERT, mhdd.server_cert_pem,
                   MHD_OPTION_DIGEST_AUTH_RANDOM, sizeof(httpd_rnd), httpd_rnd,
                   MHD_OPTION_NONCE_NC_SIZE, 300,
                   MHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 20,
                   MHD_OPTION_END);
    }
    else{
        httpd = MHD_start_daemon(MHD_USE_THREAD_PER_CONNECTION,
                   mhdd.server_port,
                   NULL,
                   NULL,
                   &mhdd_httpd_serve,
                   NULL,
                   MHD_OPTION_SOCK_ADDR, &address,
                   MHD_OPTION_DIGEST_AUTH_RANDOM, sizeof(httpd_rnd), httpd_rnd,
                   MHD_OPTION_NONCE_NC_SIZE, 300,
                   MHD_OPTION_CONNECTION_TIMEOUT, (unsigned int) 20,
                   MHD_OPTION_END);
    }
    return httpd;
}
void mhdd_httpd_stopServer(){
    MHD_stop_daemon(httpd);
}
